# 백준 11053번: 가장 긴 증가하는 부분 수열

> 문제: https://www.acmicpc.net/problem/11053

### 문제 풀이

DP, 이분 탐색

tails = 증가하는 부분 수열 중 마지막 원소의 값 중 가장 작은 수, 이 배열의 인덱스는 부분 수열의 길이 - 1

length = 증가하는 부분 수열의 최대 길이

수열 A의 원소를 앞에서부터 확인하면서 이분 탐색으로 tails에서 현재 원소보다 크거나 같은 원소 중 가장 작은 원소를 찾음

tails[left]에 현재 원소를 대입하고 만약 left가 length와 같다면 tails에 저장되있던 모든 원소가 현재 원소보다 작은 것이므로 현재까지 찾았던 증가하는 부분 수열 중 현재 부분 수열이 제일 긴 것이므로 length 1 증가

이를 모든 원소에 대해 반복하면 length에 구하는 가장 긴 증가하는 부분 수열의 길이가 저장되므로 출력하면 정답

### 풀이 설명

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

가장 긴 증가하는 부분 수열의 길이를 찾으려면 DP를 사용해 각 원소가 마지막으로 끝나는 가장 긴 증가하는 부분 수열의 길이를 찾으면 된다.

이는 dp[i] = i번째 원소로 끝나는 가장 긴 증가하는 부분 수열의 길이로 정의하고 다음과 같은 점화식으로 구한다.

dp[i] = max(dp[i], dp[j] + 1) (j번째 원소는 i번째 원소보다 앞에오면서 더 작은 원소)

이 방식으로 길이를 구하려면 매번 앞의 모든 원소를 확인해야 하므로 $O(N^2)$가 된다.

길이를 구하는 방식이 본인보다 작으면서 앞에 있는 원소의 길이보다 긴 것을 찾는 것이므로 원소의 앞에서부터 각 길이마다 증가하는 부분 수열의 마지막에 올 수 있는 가장 작은 원소들을 저장해놓으면 이 원소들 중에서 현재 원소보다 작으면서 가장 길이가 긴 증가하는 부분 수열 뒤에 현재 원소를 마지막 원소로 하면 현재 원소가 마지막 원소인 가장 길이가 긴 증가하는 부분 수열의 길이를 찾는 것이다.

또한 증가하는 부분 수열의 특징 상 이렇게 길이마다 모아놓은 마지막 원소들은 길이가 길어질수록 값이 커지므로 자동적으로 오름차순으로 정렬된다는 특징을 가지고 있다. 따라서 이 원소들과 현재 원소를 비교할 때 이분 탐색을 이용해 크기 비교를 더 빠르게 할 수 있다.

그러므로 증가하는 부분 수열의 마지막 원소 중 가장 작은 수를 저장할 배열 tails를 정의하고, 현재까지 확인했을 때 가장 긴 증가하는 부분 수열의 최대 길이 length를 저장한다.

원소를 앞에서부터 확인하면서 이분 탐색을 통해 저장된 마지막 원소 중 현재 원소보다 크거나 같은 원소 중 최솟값을 찾는다. 그러면 앞에 남은 원소들은 모두 현재 원소보다 작은 원소이므로 찾은 원소를 마지막 원소로 하는 가장 긴 증가하는 부분 수열과 현재 원소를 마지막 원소로 하는 가장 긴 증가하는 부분 수열의 길이가 같다는 것이다.

그리고 찾은 원소는 항상 현재 원소보다 크거나 같으므로 현재 원소가 찾은 길이의 증가하는 부분 수열의 마지막 원소 중 항상 가장 작은 원소가 된다는 뜻이다. 따라서 tails 배열에 현재 원소를 대입해준다.

이때 찾은 값이 이분 탐색의 끝 범위 length와 같아진다면 범위 내의 모든 값이 현재 원소보다 작다는 뜻이므로 현재 원소를 마지막 원소로 하는 가장 긴 증가하는 부분 수열의 길이가 현재까지 찾았던 가장 긴 증가하는 부분 수열의 길이보다 긴 것이므로 length를 1 증가시킨다.

이를 모든 원소에 대해 반복하면 수열 A의 가장 긴 증가하는 부분 수열의 길이가 length에 저장되므로 이를 출력하면 정답이 된다.

### 소스 코드
```kotlin
import java.io.StreamTokenizer

fun main() = StreamTokenizer(System.`in`.bufferedReader()).run {
    fun nextInt(): Int{
        nextToken()
        return nval.toInt()
    }
    val N = nextInt()
    val arr = IntArray(N)
    for(i in 0 until N){
        arr[i] = nextInt()
    }
    val tails = IntArray(N)
    var length = 0
    for(x in arr){
        var left = 0
        var right = length
        while(left < right){
            val mid = (left + right) / 2
            if(tails[mid] < x) left = mid + 1
            else right = mid
        }
        tails[left] = x
        if(left == length) length++
    }
    println(length)
}
```