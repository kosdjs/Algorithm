# 백준 11054번: 가장 긴 바이토닉 부분 수열

> 문제: https://www.acmicpc.net/problem/11054

### 문제 풀이

DP

dp[0][i] = i번째 원소를 포함하는 오름차순 수열

dp[1][i] = i번째 원소를 포함하는 중간까지 오름차순이다가 이후 부터 내림차순인 수열

max = 부분 수열 중 바이토닉 수열이 되는 최장 부분 수열의 길이

정의에 맞도록 하는 점화식은 다음과 같음

dp[0][i] = max(dp[0][i], dp[0][j]) (j < i, A[i] > A[j])

dp[1][i] = max(dp[1][i], dp[0][j], dp[1][j]) (j < i, A[i] < A[j])

점화식에 맞게 dp배열을 채우면서 max에 최댓값을 저장하고 출력하면 정답

### 풀이 설명

수열 $S$가 어떤 수 $S_k$를 기준으로 $S_1$ < $S_2$ < ... $S_{k-1}$ < $S_k$ > $S_{k+1}$ > ... $S_{N-1}$ > $S_N$을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만, {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 $A$가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구해야 하므로 부분 수열을 뽑는 방법을 생각해보면 앞에서부터 수를 하나씩 생각해보면서 해당 수가 마지막이 되는 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하면 된다.

이를 구하기 위해 바이토닉 수열의 정의를 생각해보면 특정 수의 앞에는 오름차순인 수열, 뒤에는 내림차순인 수열이 와야 하므로 한 번 내림차순인 수열이 오면 그 뒤에는 오름차순인 수열이 올 수 없다는 뜻이다.

그러므로 바이토닉 수열의 마지막 두 수를 생각해보면 오름차순인 경우, 내림차순인 경우가 있을 수 있다.

이때 오름차순인 경우는 바이토닉 수열을 성립하도록 하는 특정 수가 마지막 수인 것이므로 뒤에 수를 할 때 이전에 있던 수가 그대로 특정 수가 되도록 그 수보다 작은 수가 오는 경우가 있고, 새로 추가하는 수가 성립하게 하는 특정 수가 되도록 이전 수보다 큰 수가 되도록 하는 경우가 있다.

내림차순인 경우를 생각해보면 이미 바이토닉 수열을 성립하도록 하는 특정 수가 앞에 있는 것이므로 수를 추가해도 바이토닉 수열이 성립하려면 추가하는 수도 내림차순 수열의 일부가 되어야 하므로 이전에 있던 마지막 수보다 작은 수를 추가해야 한다.

이에 따라 dp[0][i]를 i번째 원소를 마지막 수로 하는 오름차순인 수열의 길이, dp[1][i]를 i번째 원소를 마지막 수로 하는 중간까지 오름차순이다가 내림차순인 수열의 길이로 정의한다.

정의에 따라 점화식은 다음과 같이 된다.

dp[0][i] = max(dp[0][i], dp[0][j]) (j < i, A[i] > A[j])

dp[1][i] = max(dp[1][i], dp[0][j], dp[1][j]) (j < i, A[i] < A[j])

해당 점화식에 맞는 수열들은 모두 바이토닉 수열이므로 계산하면서 최대 길이를 찾아 출력하면 정답이 된다.

### 소스 코드
```kotlin
import java.io.StreamTokenizer

fun main() = StreamTokenizer(System.`in`.bufferedReader()).run {
    fun nextInt(): Int{
        nextToken()
        return nval.toInt()
    }
    val N = nextInt()
    val A = IntArray(N)
    for(i in 0 until N){
        A[i] = nextInt()
    }
    val dp = Array(2){IntArray(N)}
    var max = 1
    for(i in 0 until N){
        for(j in 0 until i){
            if(A[i] > A[j]){
                dp[0][i] = maxOf(dp[0][i], dp[0][j])
            } else if(A[i] < A[j]){
                dp[1][i] = maxOf(dp[1][i], dp[0][j], dp[1][j])
            }
        }
        dp[0][i]++
        dp[1][i]++
        max = maxOf(max, dp[0][i], dp[1][i])
    }
    println(max)
}
```